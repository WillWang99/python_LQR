
# lqr_turn.py — Pybricks on SPIKE Prime
from pybricks.hubs import PrimeHub
from pybricks.pupdevices import Motor
from pybricks.parameters import Port, Direction, Stop, Axis
from pybricks.tools import wait, StopWatch

# --- Hardware setup (edit these for your robot) ---
hub = PrimeHub()
LeftMotor  = Motor(Port.A, Direction.CLOCKWISE)
RightMotor = Motor(Port.B, Direction.COUNTERCLOCKWISE)

# --- Controller parameters ---
DT_MS = 10                     # control loop period (ms)
MAX_SPEED = 600                # motor speed limit (deg/s) to avoid wheel skid
K_theta = 0.9                  # LQR gain on heading error (deg -> deg/s)
K_omega = 0.25                 # LQR gain on yaw rate (deg/s -> deg/s)
k_cmd   = 1.0                  # yaw-rate-to-motor-speed scale (deg/s -> deg/s), set by calibration

# --- Optional: quick calibration of k_cmd (maps motor speed to yaw rate) ---
def calibrate_k_cmd(test_speed=300, duration_ms=800):
    """Run motors in opposite directions briefly and measure average yaw rate."""
    # Ensure IMU is ready/calibrated (robot stationary) before sampling
    while not hub.imu.ready():
        wait(50)  # give hub a moment to auto-calibrate when stationary
    # Spin on the spot
    LeftMotor.run(+test_speed)
    RightMotor.run(-test_speed)
    sw = StopWatch()
    samples = []
    while sw.time() < duration_ms:
        omega = hub.imu.angular_velocity(Axis.Z)  # deg/s (yaw rate)  # uses calibrated gyro by default
        samples.append(omega)
        wait(DT_MS)
    # Stop motors and compute mapping
    LeftMotor.stop(Stop.BRAKE)
    RightMotor.stop(Stop.BRAKE)
    if len(samples) < 10:
        return 1.0
    avg_omega = sum(samples) / len(samples)
    # β ≈ ω_measured / test_speed  -> to achieve ω_ref, we need motor_speed ≈ ω_ref / β
    beta = max(1e-3, abs(avg_omega) / float(test_speed))
    return 1.0 / beta  # k_cmd = 1/β

# --- Core LQR turn (absolute) ---
def turn_to(target_deg, tol_deg=1.0, settle_ms=250, timeout_ms=6000, brake_mode=Stop.BRAKE):
    """
    Turn to an absolute heading (deg, positive clockwise).
    Uses LQR on [heading error, yaw rate] and exits when error & rate are small for 'settle_ms'.
    """
    # Safety: only reset heading when not held by a drive base
    hub.imu.reset_heading(0)  # heading starts at 0 for this turn  # reset API requirement
    wait(40)                  # small delay for stability

    # If k_cmd has not been calibrated, do it once
    global k_cmd
    if k_cmd == 1.0:
        k_cmd = calibrate_k_cmd()

    sw_total = StopWatch()
    sw_settle = StopWatch()
    sw_settle.reset()

    while sw_total.time() < timeout_ms:
        # Read state: heading error and yaw rate
        theta = hub.imu.heading()                       # deg, +clockwise from start
        omega = hub.imu.angular_velocity(Axis.Z)        # deg/s yaw rate
        e = target_deg - theta

        # LQR control law: u is desired yaw rate (deg/s)
        u = -(K_theta * e + K_omega * omega)

        # Convert to motor speeds and saturate
        cmd = max(-MAX_SPEED, min(MAX_SPEED, k_cmd * u))
        LeftMotor.run(+cmd)
        RightMotor.run(-cmd)

        # Settling logic: require low error and low rate for 'settle_ms'
        if abs(e) <= tol_deg and abs(omega) <= 3.0:
            if sw_settle.time() >= settle_ms:
                break
        else:
            sw_settle.reset()

        wait(DT_MS)

    # Stop motors cleanly
    LeftMotor.stop(brake_mode)
    RightMotor.stop(brake_mode)

# --- Convenience: relative turn (e.g., turn_by(+90)) ---
def turn_by(delta_deg, **kwargs):
    # current heading is 0 right after reset; command directly
    return turn_to(delta_deg, **kwargs)

# --- Example usage (uncomment for testing) ---
# turn_by(+90)    # turn 90° clockwise
# wait(500)
# turn_by(-90)    # turn 90° counter-clockwise
